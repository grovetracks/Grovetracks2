using System.Net.Http.Json;
using System.Text.Json;
using Grovetracks.DataAccess;
using Grovetracks.DataAccess.Entities;
using Grovetracks.DataAccess.Generation;
using Grovetracks.DataAccess.Models;
using Grovetracks.Etl.Data;
using Grovetracks.Etl.Mappers;
using Grovetracks.Etl.Models;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;

namespace Grovetracks.Etl.Operations;

public static class GenerateFocusedAiCompositionsOperation
{
    private const int DefaultPerCall = 3;
    private const int DefaultIterations = 5;
    private const int DefaultFewShotCount = 10;
    private const int FewShotExamplesPerTurn = 2;
    private const double DefaultMinQualityThreshold = 0.20;
    private const string SourceTypeValue = "ai-generated";
    private const string CuratedSourceType = "curated";

    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    public static async Task RunAsync(
        IConfiguration config,
        string subject,
        string modelName,
        int perCall = DefaultPerCall,
        int iterations = DefaultIterations,
        int fewShotCount = DefaultFewShotCount,
        bool truncate = false,
        bool dryRun = false)
    {
        var connectionString = config["ConnectionStrings:DefaultConnection"]
            ?? throw new InvalidOperationException("ConnectionStrings:DefaultConnection not configured");

        var ollamaUrl = config["Ollama:Url"] ?? "http://localhost:11434";
        var maxRetries = int.TryParse(config["Ollama:MaxRetries"], out var r) ? r : 3;
        var timeoutMinutes = int.TryParse(config["Ollama:TimeoutMinutes"], out var t) ? t : 10;
        var generationMethod = $"focused-ollama-{modelName}";

        var options = new DbContextOptionsBuilder<AppDbContext>()
            .UseNpgsql(connectionString)
            .Options;

        if (truncate && !dryRun)
        {
            Console.WriteLine($"Removing focused compositions for '{subject}' generated by {generationMethod}...");
            await using var truncateDb = new AppDbContext(options);
            var deleted = await truncateDb.SeedCompositions
                .Where(s => s.SourceType == SourceTypeValue
                    && s.GenerationMethod == generationMethod
                    && s.Word == subject)
                .ExecuteDeleteAsync();
            Console.WriteLine($"Removed {deleted:N0} compositions.");
        }

        Console.Write($"Loading curated '{subject}' examples... ");
        await using var fewShotDb = new AppDbContext(options);
        var curatedEntities = await fewShotDb.SeedCompositions
            .Where(s => s.Word == subject && s.SourceType == CuratedSourceType)
            .OrderByDescending(s => s.QualityScore)
            .Take(fewShotCount)
            .AsNoTracking()
            .ToListAsync();

        var curatedCompositions = curatedEntities
            .Select(sc => JsonSerializer.Deserialize<Composition>(sc.CompositionJson, JsonOptions)!)
            .ToList();

        Console.WriteLine($"found {curatedCompositions.Count}");

        if (curatedCompositions.Count == 0)
        {
            Console.WriteLine($"ERROR: No curated examples found for '{subject}'.");
            Console.WriteLine("Run 'curate-simple-doodles' first to create curated examples.");
            return;
        }

        var fewShotPairs = BuildFewShotPairs(subject, curatedCompositions);
        var messages = FocusedAiCompositionPrompts.BuildMessages(subject, perCall, fewShotPairs);

        Console.WriteLine($"Ollama URL: {ollamaUrl}");
        Console.WriteLine($"Model: {modelName}");
        Console.WriteLine($"Subject: {subject}");
        Console.WriteLine($"Per call: {perCall} compositions");
        Console.WriteLine($"Iterations: {iterations}");
        Console.WriteLine($"Few-shot: {curatedCompositions.Count} curated examples in {fewShotPairs.Count} conversation turns");
        Console.WriteLine($"Generation method: {generationMethod}");
        Console.WriteLine($"Mode: {(dryRun ? "DRY RUN" : "LIVE")}");
        Console.WriteLine();

        if (dryRun)
        {
            Console.WriteLine("=== DRY RUN — No API calls or database writes ===");
            Console.WriteLine($"Would generate up to {iterations * perCall:N0} compositions of '{subject}'");
            Console.WriteLine($"Estimated API calls: {iterations}");
            Console.WriteLine();

            Console.Write("Checking Ollama connectivity... ");
            using var checkClient = new HttpClient { Timeout = TimeSpan.FromSeconds(10) };
            try
            {
                var tagsResponse = await checkClient.GetAsync($"{ollamaUrl}/api/tags");
                tagsResponse.EnsureSuccessStatusCode();
                var tagsJson = await tagsResponse.Content.ReadAsStringAsync();
                var modelExists = tagsJson.Contains(modelName, StringComparison.OrdinalIgnoreCase);
                Console.WriteLine(modelExists
                    ? $"OK (model '{modelName}' found)"
                    : $"OK (connected, but model '{modelName}' not found — pull it first)");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"FAILED ({ex.Message})");
            }

            Console.WriteLine();
            Console.WriteLine($"Curated examples (top {curatedCompositions.Count} by quality):");
            for (var i = 0; i < curatedEntities.Count; i++)
            {
                var e = curatedEntities[i];
                Console.WriteLine($"  {i + 1}. quality={e.QualityScore:F4}, strokes={e.StrokeCount}, points={e.TotalPointCount}");
            }
            return;
        }

        using var httpClient = new HttpClient { Timeout = TimeSpan.FromMinutes(timeoutMinutes) };

        Console.Write("Verifying Ollama is reachable... ");
        try
        {
            var tagsResponse = await httpClient.GetAsync($"{ollamaUrl}/api/tags");
            tagsResponse.EnsureSuccessStatusCode();
            var tagsJson = await tagsResponse.Content.ReadAsStringAsync();
            if (!tagsJson.Contains(modelName, StringComparison.OrdinalIgnoreCase))
            {
                Console.WriteLine($"WARNING: model '{modelName}' not found. Pull it first:");
                Console.WriteLine($"  curl -X POST {ollamaUrl}/api/pull -d '{{\"name\":\"{modelName}\"}}'");
                return;
            }
            Console.WriteLine("OK");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FAILED — cannot reach Ollama at {ollamaUrl}: {ex.Message}");
            return;
        }

        using var cts = new CancellationTokenSource();
        var cancelled = false;

        Console.CancelKeyPress += (_, e) =>
        {
            e.Cancel = true;
            cancelled = true;
            cts.Cancel();
            Console.WriteLine();
            Console.WriteLine("Shutting down gracefully, saving pending compositions...");
        };

        var totalGenerated = 0;
        var totalValid = 0;
        var totalRejectedInvalid = 0;
        var totalRejectedLowQuality = 0;
        var qualityScores = new List<double>();
        var rejectionReasons = new Dictionary<string, int>();

        Console.WriteLine();
        for (var iteration = 1; iteration <= iterations; iteration++)
        {
            if (cancelled)
                break;

            var progress = $"[{iteration}/{iterations}]";

            for (var attempt = 0; attempt <= maxRetries; attempt++)
            {
                if (cancelled)
                    break;

                try
                {
                    var temperature = 0.3 + (attempt * 0.2);

                    var requestBody = new
                    {
                        model = modelName,
                        messages,
                        stream = false,
                        format = AiCompositionPrompts.CompositionSchema,
                        options = new
                        {
                            num_predict = 8192,
                            temperature,
                            top_p = 0.9,
                            repeat_penalty = 1.1
                        }
                    };

                    var response = await httpClient.PostAsJsonAsync(
                        $"{ollamaUrl}/api/chat", requestBody, cts.Token);
                    response.EnsureSuccessStatusCode();

                    var ollamaResponse = await response.Content.ReadFromJsonAsync<OllamaChatResponse>(
                        JsonOptions, cts.Token);

                    if (ollamaResponse?.Message.Content is null)
                    {
                        if (attempt == maxRetries)
                            Console.WriteLine($"  {progress} no content in response after {maxRetries + 1} attempts");
                        continue;
                    }

                    var batch = JsonSerializer.Deserialize<AiCompositionBatch>(
                        ollamaResponse.Message.Content, JsonOptions);

                    if (batch?.Compositions is null || batch.Compositions.Count == 0)
                    {
                        if (attempt == maxRetries)
                            Console.WriteLine($"  {progress} empty or invalid response after {maxRetries + 1} attempts");
                        continue;
                    }

                    var iterationGenerated = 0;
                    var iterationValid = 0;
                    var iterationBatch = new List<SeedComposition>();

                    foreach (var aiComp in batch.Compositions)
                    {
                        iterationGenerated++;
                        totalGenerated++;

                        var composition = AiCompositionMapper.MapToComposition(aiComp, generationMethod);
                        var (isValid, qualityScore) = CompositionValidator.Validate(composition);

                        if (!isValid)
                        {
                            totalRejectedInvalid++;
                            var reason = DiagnoseRejection(composition);
                            rejectionReasons[reason] = rejectionReasons.GetValueOrDefault(reason) + 1;
                            continue;
                        }

                        qualityScores.Add(qualityScore);

                        if (qualityScore < DefaultMinQualityThreshold)
                        {
                            totalRejectedLowQuality++;
                            rejectionReasons["low quality score"] = rejectionReasons.GetValueOrDefault("low quality score") + 1;
                            continue;
                        }

                        var compositionJson = JsonSerializer.Serialize(composition, JsonOptions);

                        iterationBatch.Add(new SeedComposition
                        {
                            Id = Guid.NewGuid(),
                            Word = subject,
                            SourceKeyId = "ai-generated",
                            QualityScore = qualityScore,
                            StrokeCount = CompositionGeometry.CountTotalStrokes(composition),
                            TotalPointCount = CompositionGeometry.CountTotalPoints(composition),
                            CompositionJson = compositionJson,
                            CuratedAt = DateTime.UtcNow,
                            SourceType = SourceTypeValue,
                            GenerationMethod = generationMethod,
                            SourceCompositionIds = null
                        });

                        iterationValid++;
                        totalValid++;
                    }

                    if (iterationBatch.Count > 0)
                        await FlushBatchAsync(options, iterationBatch);

                    Console.WriteLine($"  {progress} {iterationGenerated} generated, {iterationValid} valid (saved)" +
                        (iterationValid > 0 ? $" — avg quality: {iterationBatch.Average(c => c.QualityScore):F4}" : ""));
                    break;
                }
                catch (OperationCanceledException)
                {
                    Console.WriteLine($"  {progress} cancelled");
                    goto loopEnd;
                }
                catch (Exception ex) when (attempt < maxRetries)
                {
                    Console.WriteLine($"  {progress} attempt {attempt + 1} failed — {ex.Message}, retrying...");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"  {progress} ERROR — {ex.Message}");
                }
            }
        }

        loopEnd:
        Console.WriteLine();
        var acceptanceRate = totalGenerated > 0 ? (double)totalValid / totalGenerated * 100 : 0;
        var avgQuality = qualityScores.Count > 0 ? qualityScores.Average() : 0;

        if (cancelled)
        {
            Console.WriteLine($"=== Focused Generation Summary (Cancelled) ===");
            Console.WriteLine($"  Subject:    {subject}");
            Console.WriteLine($"  Model:      {modelName}");
            Console.WriteLine($"  Generated:  {totalGenerated:N0}");
            Console.WriteLine($"  Saved:      {totalValid:N0}");
            Console.WriteLine("  All completed iterations were saved to the database.");
        }
        else
        {
            Console.WriteLine($"=== Focused Generation Summary ===");
            Console.WriteLine($"  Subject:    {subject}");
            Console.WriteLine($"  Model:      {modelName}");
            Console.WriteLine($"  Generated:  {totalGenerated:N0}");
            Console.WriteLine($"  Valid:      {totalValid:N0}");
        }

        Console.WriteLine();
        Console.WriteLine("=== Quality Diagnostics ===");
        Console.WriteLine($"  Acceptance rate:   {acceptanceRate:F1}% ({totalValid}/{totalGenerated})");
        Console.WriteLine($"  Avg quality score: {avgQuality:F4} (of those scoring)");
        Console.WriteLine($"  Rejected invalid:  {totalRejectedInvalid}");
        Console.WriteLine($"  Rejected quality:  {totalRejectedLowQuality} (below {DefaultMinQualityThreshold})");
        if (rejectionReasons.Count > 0)
        {
            Console.WriteLine("  Rejection reasons:");
            foreach (var (reason, count) in rejectionReasons.OrderByDescending(r => r.Value))
                Console.WriteLine($"    {reason}: {count}");
        }
    }

    private static IReadOnlyList<(string UserPrompt, string AssistantResponse)> BuildFewShotPairs(
        string subject,
        List<Composition> curatedCompositions)
    {
        var pairs = new List<(string, string)>();

        for (var i = 0; i < curatedCompositions.Count; i += FewShotExamplesPerTurn)
        {
            var chunk = curatedCompositions
                .Skip(i)
                .Take(FewShotExamplesPerTurn)
                .ToList();

            var batch = FewShotExampleMapper.MapToAiBatch(subject, chunk);
            var json = FewShotExampleMapper.SerializeToJson(batch);
            var prompt = $"Draw {chunk.Count} distinct variation{(chunk.Count > 1 ? "s" : "")} of: {subject}";

            pairs.Add((prompt, json));
        }

        return pairs.AsReadOnly();
    }

    private static string DiagnoseRejection(Composition composition)
    {
        if (composition.DoodleFragments.Count == 0)
            return "no fragments";

        var totalStrokes = CompositionGeometry.CountTotalStrokes(composition);
        if (totalStrokes == 0)
            return "no strokes";

        var totalPoints = CompositionGeometry.CountTotalPoints(composition);
        if (totalPoints < 5)
            return $"too few points ({totalPoints})";

        foreach (var fragment in composition.DoodleFragments)
        {
            foreach (var stroke in fragment.Strokes)
            {
                var xs = stroke.Data[0];
                var ys = stroke.Data[1];
                for (var j = 0; j < xs.Count; j++)
                {
                    if (xs[j] < 0 || xs[j] > 1 || ys[j] < 0 || ys[j] > 1)
                        return "out of bounds coordinates";
                }
            }
        }

        var (minX, minY, maxX, maxY) = CompositionGeometry.ComputeBoundingBox(composition);
        var bboxCoverage = (maxX - minX) * (maxY - minY);
        if (bboxCoverage < 0.10)
            return $"bounding box too small ({bboxCoverage:F3})";

        return "unknown";
    }

    private static async Task FlushBatchAsync(
        DbContextOptions<AppDbContext> options,
        List<SeedComposition> batch)
    {
        await using var db = new AppDbContext(options);
        db.SeedCompositions.AddRange(batch);
        await db.SaveChangesAsync();
    }
}
